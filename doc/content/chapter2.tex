
\chapter{List processing}

Lists are one of the most important data structures used in functional programming and every major programming language provides means of finite sequence storage. KamilaLisp is no different and a special emphasis is put on list and array processing, the basic building block of dataflow programming.

As mentioned before, every list besides the empty list contains a \textit{head} (the first element, \verb|car|) and a \textit{tail} (the last element, \verb|cdr|). The tail of a list is always another list, even if it is empty. The empty list literal is introduced in the code as \verb|'nil| or \verb|'()|. 

\section{Basic list operations}

Using \verb|car| and \verb|cdr| it is possible to define a basic, non-tail recursive function that yields the length of a list:

\begin{Verbatim}
    --> defun length l (if (same l 'nil) 0 (+ 1 (length (cdr l))))
    (Î» l . (if (same l 'nil) 0 (+ 1 (length (cdr l)))))
\end{Verbatim}

A generalised version of this function that handles scalar values, variadic application and strings is available as \verb|tally|\footnote{\textit{tally} - to count or calculate something}:

\begin{Verbatim}
    --> tally '(1 2 3) '(4 5)
    (3 2)
    --> tally '(1 2 3 4 5)
    5
    --> tally "abcde"
    5
    --> tally 5
    1
    --> tally
    0
\end{Verbatim}

Individual elements may be prepended to a list using the \verb|cons| function:

\begin{Verbatim}
    --> cons 6 'nil
    (6)
    --> cons 5 (cons 6 'nil)
    (5 6)
    --> cons 1 '(2 3)
    (1 2 3)
\end{Verbatim}

Hence, one could define a countdown function as follows:

\begin{Verbatim}
    --> defun countdown x (if x (cons x (countdown (- x 1))) '(0))
    (Î» x . (if x (cons x (countdown (- x 1))) '(0)))
    --> countdown 5
    (5 4 3 2 1 0)
\end{Verbatim}

Once again, a general result of this function is available in KamilaLisp as the \verb|range| function:

\begin{Verbatim}
    --> range 5
    (0 1 2 3 4)
    --> range 5 10
    (5 6 7 8 9)
    --> range 10 5
    (10 9 8 7 6)
    --> range 5 -5
    (5 4 3 2 1 0 -1 -2 -3 -4)
\end{Verbatim}

List concatenation in KamilaLisp is accomplished using the \verb|append| function. The \verb|append| function is of course variadic and accepts an empty parameter list:

\begin{Verbatim}
    --> append '(1 2 3) '(4 5)
    (1 2 3 4 5)
    --> append '(1 2 3) '(4 5) '(6 7)
    (1 2 3 4 5 6 7)
    --> append
    'nil
    --> append 'nil 'nil
    'nil
    --> append "Tomato" "sauce"
    Tomatosauce
\end{Verbatim}

Prefixes and suffixes of lists may be extracted using the \verb|take| and \verb|drop| functions as follows:

\begin{Verbatim}
    --> take 3 '(1 2 3 4 5)
    (1 2 3)
    --> drop 3 '(1 2 3 4 5)
    (4 5)
    --> take 3 '(1 2 3)
    (1 2 3)
    --> drop 3 '(1 2 3)
    --> take 3 'nil
    [[]
     []
     []]
    --> drop 3 'nil
    --> take 5 '(1 2 3)
    (1 2 3 0 0)
\end{Verbatim}

The \verb|take| and \verb|drop| functions also accept negative argument, which changes the direction of the operation:

\begin{Verbatim}
    --> take -3 "KamilaLisp is Fun"
    Fun
\end{Verbatim}

More generally, \textit{all} prefixes and suffixes of a list are extracted using the \verb|prefixes| and \verb|suffixes| functions:

\begin{Verbatim}
    --> prefixes '(1 2 3 4 5)
    ((1) (1 2) (1 2 3) (1 2 3 4) (1 2 3 4 5))
    --> suffixes '(1 2 3 4 5)
    ((1 2 3 4 5) (2 3 4 5) (3 4 5) (4 5) (5))
    --> suffixes "Lisp"
    ("Lisp" "isp" "sp" "p")
\end{Verbatim}

Going back to the \verb|take| function, it is easy to notice that when the list is shorter than expected, the resultant list is simply padded with zeroes. This may not be the desired behaviour, thus a variant of \verb|take| called \verb|cycle| is provided. The \verb|cycle| function takes a list and a number and returns a list of the same length as the number, where the elements are taken from the list in a cyclic manner:

\begin{Verbatim}
    --> cycle 5 '(1 2 3)
    (1 2 3 1 2)
    --> cycle 3 '(1 2 3)
    (1 2 3)
    --> cycle 2 '(1 2 3)
    (1 2)
    --> cycle 1 '(1 2 3)
    (1)
    --> cycle 0 '(1 2 3)
    --> cycle -1 '(1 2 3)
    RuntimeException thrown in thread 1dbd16a6:
            cycle: negative length
        at entity cycle  1:1
        at cycle primitive function
    --> cycle 'nil 5
    --> cycle "abc" 5
    abcab
\end{Verbatim}

The \verb|replicate| function ubiquitously used in APL and Haskell is also available in KamilaLisp, except its domain is extended to scalar values:

\begin{Verbatim}
    --> replicate 3 5
    (5 5 5)
    --> replicate 5 '(1 2 3)
    (1 2 3 1 2 3 1 2 3 1 2 3 1 2 3)
    --> replicate 5 "Kamila"
    KamilaKamilaKamilaKamilaKamila
    --> replicate 0 5
    --> replicate 5 'nil
    --> replicate '(1 2 3) '(4 5 6)
    (4 5 5 6 6 6)
\end{Verbatim}

KamilaLisp also provides a few functions for altering the \textit{order} of elements in a list. The \verb|reverse| function reverses the order of elements in a list:

\begin{Verbatim}
    --> reverse '(1 2 3 4 5)
    (5 4 3 2 1)
    --> reverse "KamilaLisp"
    psiLalimaK
\end{Verbatim}

The \verb|rotate| function, as the name suggests, takes a list and a number and returns a list where the elements are rotated by the number:

\begin{Verbatim}
    --> rotate 2 '(1 2 3 4 5)
    (3 4 5 1 2)
    --> rotate -2 '(1 2 3 4 5)
    (4 5 1 2 3)
    --> rotate -4 "KamilaLisp"
    LispKamila
    --> rotate 1 'nil
    --> rotate 0 'nil
\end{Verbatim}

Finally, the \verb|list:shuffle| function will take a list and return a list with the same elements, but in a random order:

\begin{Verbatim}
    --> list:shuffle '(1 2 3 4 5)
    (2 5 3 1 4)
    --> list:shuffle "KamilaLisp"
    LpLsikmaia
\end{Verbatim}

\section{Sorting, searching and indexing}

KamilaLisp uses a special syntax for indexing into lists. The syntax is as follows:

\begin{Verbatim}
    --> def x '(1 5 2 3 4)
    (1 5 2 3 4)
    --> ?x$[#0 0]
    1
\end{Verbatim}

This syntax is very confusing when demonstrated in isolation. First, indexing returns a value without a function call involved, so it is mandatory to tell the interpreter that the intent is to obtain the value of an object, hence the \verb|?| prefix in the REPL. Furthermore, the contents of square brackets in the indexing syntax are interpreted \textit{as an expression}, hence it is needed to use \verb|#0| (the \textit{identity} function - a function that applied to an argument simply returns it). Finally, it is possible to index a list using a list, as follows:

\begin{Verbatim}
    --> ?x$[tie 1 3 4]
    (5 3 4)
\end{Verbatim}

The indexing function loops over the list it has received and returns respectively the first, third and fourth items of a list, all packed together into a single array. This is a very powerful feature, as it allows for a very concise syntax for extracting elements from a list, applying permutations and even sorting, as demonstrated later in the book.

Another closely related functionality related to indexing is searching. The \verb|index-of| takes a value and a list and returns the index of the first occurrence of the value in the list:

\begin{Verbatim}
    --> index-of 5 '(9 8 6 5 4 7 2 3)
    3
    --> index-of 5 '(9 8 6 4 7 2 3)
    -1
\end{Verbatim}