
\chapter{Initial considerations}

This chapter discusses the basics of KamilaLisp. Throughout this book, the author will use the KamilaLisp interpreter to check and execute the declarations of a program one by one. The emphasis will be put on list processing and mathematical functions to form elementary understanding of the language.

\section{Programs and variables}

A KamilaLisp program is a sequence of declarations, which are executed in the order they are written. The first program presented in this book is shown below:

\begin{Verbatim}
    --> def a (+ (* 2 3) 2)
    8
    --> def b (* 5 a)
    40
\end{Verbatim}

It consists of two declarations. The first declaration binds the identifier a to the integer 8, and the second declaration binds the identifier b to the integer 40, which follows from the intuitive understanding of the arithmetic operations. To the reader not accustomed with Lisp-like syntax, every element of the syntax tree that would otherwise be implicitly grouped by a language with usual arithmetical precedence rules is explicitly grouped by parentheses to form a list. The resulting values of variables can be determined as follows:

\begin{Verbatim}
    --> ?a
    8
    --> ?b
    40
\end{Verbatim}

The question mark is a sign for the KamilaLisp interpreter not to evaluate the entire input as an expression, but rather, to query the value of what it refers to.

Every list besides the empty list (usually written as \verb|`()'| or alternatively \verb|nil|) has a \textit{head} defined as the first element of it. When a Lisp program is evaluated, the \textit{head} of the current list is assumed to be a callable value, while the rest of the list (also called the \textit{tail}) is assumed to be a list of arguments.

Because the list of arguments to a function (the \textit{tail}) is evaluated before its applied to the \textit{head}, a perceptive reader could point out a potential issue - \textit{How to introduce list literals in the code}? This question is indeed well-founded, since the list literal would be evaluated in order to pass it parameter to some callable object, hence the tail of the literal would be applied to its head, thus behaving undesirably and almost certainly raising an error. Every Lisp dialect addresses this issue in the same way using the quoting mechanism. Simply put, the quote prevents a list from being evaluated. To observe this behaviour, introduce two more functions called \verb|car| and \verb|cdr| to obtain respectively the \textit{head} and \textit{tail} of a list:

\begin{Verbatim}
    --> car '(1 2 3)
    1
    --> cdr '(1 2 3)
    (2 3)
\end{Verbatim}

KamilaLisp follows scoping rules familiar from other programming languages, such as Scheme or C++ - \textit{static scoping} (also called \textit{lexical scoping}), where an attempt is initially made to resolve a variable in the current scope. If this approach fails, the variable is resolved in the scope of its lexical ancestors until either the interpreter finds an environment where the variable is bound, or raises an error regarding an unbound variable. Additionally, variables may be \textit{shadowed}, as demonstrated below:

\begin{Verbatim}
    --> def my-list '(1 2 3)
    (1 2 3)
    --> car my-list
    1
    --> def my-list (cdr my-list)
    (2 3)
    --> car my-list
    2
\end{Verbatim}

However, it is not possible to shadow pre-defined variables and functions in the global scope:

\begin{Verbatim}
    --> def car 5
    RuntimeException thrown in thread 1dbd16a6:
            def can not shadow or redefine built-in bindings.
        at entity def  1:1
        at def primitive function
\end{Verbatim}

To fully exercise lexical scoping, the language needs to provide a way of binding names inside a specific block of code (unlike \textit{def} which binds names in the global scope). This can be accomplished in a variety of ways, the most straight-forward one being the \textit{let} construct. The \textit{let} construct binds a list of name/value pairs, and evaluates the body of the construct in the context of the newly created environment. The syntax of the \textit{let} construct is demonstrated by the following example:

\begin{Verbatim}
    --> def a 5
    5
    --> def b 6
    6
    --> + a b
    11
    --> let ((a 10) (b 15)) (+ a b)
    25
\end{Verbatim}

\section{Functions and lambda expressions}

Functions are the core component of KamilaLisp. They are first-class objects, which means that they can be passed as arguments to other functions, returned from functions, and assigned to variables. The syntax of a function declaration is as follows:

\begin{Verbatim}
    --> defun square (x) (* x x)
    (λ x . (* x x))
\end{Verbatim}

The function that has just been declared is called \verb|square|, and it takes one argument called \verb|x|. The body of the function is the expression \verb|(* x x)|. The function returns the value of their expression, which is simply the square of the argument. Notice that when defining a monadic function, a pair of parentheses can be omitted for brevity:

\begin{Verbatim}
    --> defun square x (* x x)
    (λ x . (* x x))
\end{Verbatim}

Since \verb|square| is now bound in the global scope, it can be applied to an argument. The code below binds the result of application of the number 5 to the function \verb|square| to the variable \verb|a|:

\begin{Verbatim}
    --> def a (square 5)
    25
\end{Verbatim}

Functions do not need to be named. They can be introduced in the code \textit{anonymously} using the \textit{lambda} construct, which opens up many new possibilities. For example, the declaration of the function \verb|square| can be rewritten as follows:

\begin{Verbatim}
    --> def square (lambda x (* x x))
    (λ x . (* x x))
\end{Verbatim}

Furthermore, multivariate lambda expressions could serve as a replacement for the \textit{let} construct:

\begin{Verbatim}
    --> let ((a 10) (b 15)) (+ a b)
    25
    --> (lambda (a b) (+ a b)) 10 15
    25
\end{Verbatim}

Since functions are first-class in KamilaLisp, it is now also possible to return them from functions and take them as arguments. The following example demonstrates these programming techniques using the \textit{lambda} construct:

\begin{Verbatim}
    --> ; Returns a function that adds a given number to its argument.
    --> ; The technique demonstrated is often called "currying".
    --> defun make-adder (x) (lambda y (+ x y))
    (λ x . (λ y . (+ x y)))
    --> def add-5 (make-adder 5)
    (λ y . (+ 5 y))
    --> add-5 10
    15
    --> ; Returns a string explaining the value of a function at point.
    --> defun explain (f x) (str:format "The value of f(x) for x={?x} is {f x}")
    (λ f x . (str:format "The value of f(x) for x={?x} is {f x}"))
    --> explain square 4.5
    The value of f(x) for x=4.5 is 20.25
\end{Verbatim}

When writing complex functions, it is of particular interest to keep the partial results obtained during the execution of the function. This can be achieved by cascading the \textit{let} construct, or using the \textit{let-seq} construct. The following examples implement a function that raises its first argument to the eigth power:

\begin{Verbatim}
    --> defun p8 x (let-seq (
    ...   (def y (* x x))
    ...   (def z (* y y))
    ...   (* z z)))
    (λ x . (let-seq ((def y (* x x)) (def z (* y y)) (* z z))))
    --> p8 4
    65536
    --> defun p8 x (let ((y (* x x))) (let ((z (* y y))) (* z z)))
    (λ x . (let ((y (* x x)) (z (* y y))) (* z z)))
    --> p8 4
    65536
    --> defun p8 x (let ((y (* x x)) (z (* y y))) (* z z))
    (λ x . (let ((y (* x x)) (z (* y y))) (* z z)))
    --> p8 4
    65536
\end{Verbatim}

Notice that despite using \verb|def|, \verb|defun|, etc..., the \textit{let-seq} construct does not create any bindings in the global scope - the bindings are local to the block.

\section{Conditional expressions and comparisons}

The comparison operators in KamilaLisp don't differ significantly from the ones present in other, perhaps more orthodox programming languages (such as C). It is worth noting that equality is checked using the \verb|=| function, inequality is checked for using the \verb|/=| function, while the \verb|<=>| function is the so-called \textit{three way comparison} operator, which returns -1, 0 or 1 respectively if the first argument is less than, equal to, or greater than the second argument.

KamilaLisp provides a number of conditional expressions, which are used to control the flow of execution. The most basic one is the \textit{if} construct, which takes three arguments - a condition, an expression to be evaluated if the condition is true, and an expression to be evaluated if the condition is false. The syntax of the \textit{if} construct is demonstrated by the following example:

\begin{Verbatim}
    --> defun my-abs x (if (< x 0) (- x) x)
    (λ x . (if (< x 0) (- x) x))
    --> my-abs -5
    5
    --> my-abs 5
    5
    --> my-abs 0
    0
\end{Verbatim}

The \textit{if} construct is a special case of the \textit{cond} construct, which takes a list of pairs of conditions and expressions. The first condition that evaluates to true is used to evaluate the corresponding expression. The syntax of the \textit{cond} construct is demonstrated by the following reimplementation of the three-way comparison operator:

\begin{Verbatim}
    --> defun compare (x y) (cond ((< x y) -1) ((> x y) 1) (0))
    (λ x y . (cond ((< x y) -1) ((> x y) 1) (0)))
    --> compare 5 10
    -1
    --> compare 10 5
    1
    --> compare 5 5
    0
\end{Verbatim}

\section{Recursive functions}

Recursion is a powerful technique extensively used in functional programming. Its role in KamilaLisp is admittedly not as important as in other functional programming languages, since the language provides a number of other often more wieldy techniques for solving the same problems (e.g. using array programming). However, it is still worth mentioning that KamilaLisp provides a number of tools for writing recursive functions.

The following function implements the \textit{factorial} function in a recursive manner:

\begin{Verbatim}
    --> defun factorial (n) (if (= n 0) 1 (* n (factorial (- n 1))))
    (λ n . (if (= n 0) 1 (* n (factorial (- n 1)))))
    --> factorial 5
    120
\end{Verbatim}

Since KamilaLisp supports arbitrary precision integers, the factorial function can be applied to arbitrarily large numbers. However, at some point, this function will \textit{overflow its stack}, since the number of recursive calls will exceed the maximum stack size. This is a common problem in recursive functions, and it can be solved by using the \textit{tail recursion} technique. Tail recursion is a special case of recursion, where the recursive call is the last expression in the function body. In this case, the stack frame of the current function can be reused for the recursive call, which means that the stack will not grow indefinitely. To make use of this technique, the factorial function needs to be altered so that the recursive call is the last expression in the function body:

\begin{Verbatim}
    --> defun factorial (n) (let-seq (
    ...   (defun f' (n acc) (if (= n 0) acc (f' (- n 1) (* n acc))))
    ...   (f' n 1)))
    (λ n . (let-seq ((defun f' (n acc) (if (= n 0) acc (f' (- n 1) (* n acc)))) (f' n 1))))
    --> factorial 5
    120
\end{Verbatim}

The factorial function defines a helper function that has an accumulator argument, which is used to store the intermediate results of the computation. The helper function is called recursively, and the accumulator argument is updated with the result of the multiplication. The \textit{let-seq} construct is used to define the helper function, so that it is not visible outside the factorial function. There is one more step to make this function tail-recursive: redefine the self-referential call to the helper function:

\begin{Verbatim}
    --> defun factorial (n) (let-seq (
    ...   (defun f' (n acc) (if (= n 0) acc (&0 (- n 1) (* n acc))))
    ...   (f' n 1)))
    (λ n . (let-seq ((defun f' (n acc) (if (= n 0) acc (&0 (- n 1) (* n acc)))) (f' n 1))))
    --> factorial 5
    120
\end{Verbatim}

The self-referential call was replaced by \verb|&0|, which in simple terms is a reference to the current function. This is a special case of the \verb|&| operator, which is used to refer to functions by nesting level in the source code, akin to de Bruijn indices. The \verb|&0| operator refers to the current function, \verb|&1| refers to the function (anonymous or named) that is the lexical ancestor the current function, and so on. This way, the factorial function no longer errors when applied to large numbers, since the stack does not grow indefinitely:

\begin{Verbatim}
    --> factorial 1000
    402387260077093773543702433923003985719374864210714
    632543799910429938512398629020592044208486969404800
    ; [...]
    000000000000000000000000000000000000000000000000000
    000000000000000000000000000000000000000000000000000
\end{Verbatim}

\section{Function composition}

Function composition is a a common core concept in functional programming languages, an emphasis on which is placed in KamilaLisp. Using the \verb|@| operator, it is possible to compose two or more functions into a single function. An example follows:

\begin{Verbatim}
    --> defun f x (* x 2)
    (λ x . (* x 2))
    --> defun g x (+ x 1)
    (λ x . (+ x 1))
    --> f 2
    4
    --> g 2
    3
    --> f@g 2
    6
\end{Verbatim}

The usefulness of function composition might be hard to appreciate at first. In the end, \verb|f@g x| $\Leftrightarrow$ \verb|f (g x)|, however, the function returned by the \verb|@| operator does not have to be immediately applied - it can be bound to a name and used later. Without the composition operator, it would be necessary to introduce a \textit{lambda} to achieve the same result as \verb|f@g| - that is, \verb|lambda x (f (g x))|. The difference between manually composing two functions to create a new function and using the \verb|@| operator is how they treat arguments. The \verb|@| operator variant of the same expression does not refer to the arguments of the composed functions (and thus does not manually relay an indeterminate amount of them to the innermost function), creating the basic building block for \textit{point-free programming}.

Of course, it is possible to compose arbitrarily many functions by using the \verb|@| operator multiple times. The following example demonstrates the composition of three functions:

\begin{Verbatim}
    --> defun f x (* x 2)
    (λ x . (* x 2))
    --> defun g x (+ x 1)
    (λ x . (+ x 1))
    --> defun h x (- x 3)
    (λ x . (- x 3))
    --> f@g@h 2
    0
\end{Verbatim}

Another form of function composition notoriously used in the APL family of programming languages is the so-called \textit{fork} (the \mu-recursive composition operator). Generally speaking, it is sometimes of special interest to preprocess the arguments using different functions (\textit{reductees}), and then funnel the results into a single function (\textit{reductor}). For instance, the arithmetic mean is defined as the quotient (\textit{reductor}) of the sum and length of a list (\textit{reductees}), while a palindrome is defined as a string for which the equality (\textit{reductor}) between it and its reverse (\textit{reductees}).

To implement a sum function using a fork, it is necessary to define a function that sums a list beforehand using the \verb|tally| function which returns the length of a list. A non-zero value is considered truthy, hence the following definition of the \textit{sum} function:

\begin{Verbatim}
    --> defun sum (l) (if (tally l) (+ (car l) (sum (cdr l))) 0)
    (λ l . (if (tally l) (+ (car l) (sum (cdr l))) 0))
    --> sum '(1 6 2 3)
    12
\end{Verbatim}

There are many alternative ways to implement it. One problem the reader may stumble upon is \verb|= 'nil 'nil| returning \verb|'nil|. This behaviour is reasoned by the fact that equality \textit{vectorises} over lists, meaning that equality is tested element-wise. To determine structural equality, it is advised to use the \verb|same| function. The following example demonstrates this behaviour:

\begin{Verbatim}
    --> = '(1 2 3) '(1 2 4)
    (1 1 0)
    --> same '(1 2 3) '(1 2 4)
    0
    --> same '(1 2 3) '(1 2 3)
    0
\end{Verbatim}

Hence arguing for a simpler implementation of the \textit{sum} function:
\begin{Verbatim}
    --> defun sum (l) (if (same l '()) 0 (+ (car l) (sum (cdr l))))
    (λ l . (if (same l '()) 0 (+ (car l) (sum (cdr l)))))
    --> sum '(1 6 2 3)
    12
\end{Verbatim}

The arithmetic mean function is thusly introduced as follows:

\begin{Verbatim}
    --> [/ sum tally] '(1 6 2 3 4)
    3.2
\end{Verbatim}

Of course, it could also be bound to a name without applying the fork instantaneously:

\begin{Verbatim}
    --> def avg [/ sum tally]
    [/ sum tally]
    --> avg '(1 6 2 3 4)
    3.2
\end{Verbatim}

The key merits of point-free programming are:

\begin{itemize}
    \item The code is more concise.
    \item The code is often more readable.
    \item The code is faster, because there is no need to allocate a stack frame.
    \item The code does not need to bind any names.
\end{itemize}

\section{Partial application and \texorpdfstring{$\mu$}{mu}-recursive functions}

Most functional programming languages, such as OCaml and Haskell automatically \textit{curry} functions by default, that is, allow applying functions to fewer arguments than they are defined to take. This is a useful feature, because it allows for the creation of new functions by binding some of the arguments of a function to a value. This is called \textit{partial application}. KamilaLisp supports partial application of functions but it does not happen by default, since unlike OCaml and Haskell, KamilaLisp supports variadic functions. Recall the following example given earlier in the book:

\begin{Verbatim}
    --> ; Returns a function that adds a given number to its argument.
    --> ; The technique demonstrated is often called "currying".
    --> defun make-adder (x) (lambda y (+ x y))
    (λ x . (λ y . (+ x y)))
    --> def add-5 (make-adder 5)
    (λ y . (+ 5 y))
    --> add-5 10
    15
\end{Verbatim}

Using partial application, the example can be rewritten as follows:

\begin{Verbatim}
    --> defun add-x n $(+ n)
    (λ n . $(+ n))
    --> def add-5 (add-x 5)
    $(+ n)
    --> add-5 6
    11
\end{Verbatim}

Partial application is particularly useful in conjunction with various kinds of function composition, as it allows for the vast majority of functions that are defined in terms of other functions to be defined in a point-free manner.

Variadic functions were briefly mentioned earlier in the book. Simply speaking, they are functions that take an arbitrary number of arguments. \verb|+| is a good example of a variadic function, since when applied to more than two arguments, it just sums everything:

\begin{Verbatim}
    --> + 1 2 3 4 5
    15
\end{Verbatim}

It is possible to define custom variadic functions in KamilaLisp using special argument syntax. To recall, \verb|lambda (x y) (code)| takes two arguments - \textit{x} and \textit{y}. This function can be made variadic by prepending the \textit{last argument} with an ellipsis - \verb|lambda (x ...xs) (code)|. The last argument is bound to a list of all the remaining arguments. This has an interesting property: while the aforementioned function takes \textit{at least} one argument (because \verb|...xs| can be empty), it can be modified to take any amount of arguments, even zero - \verb|lambda ...xs (code)|. To demonstrate this behaviour, the following function will obtain the arithmetic average of all its arguments, but will refuse to be called with zero arguments:

\begin{Verbatim}
    --> defun avg (x ...xs) (/ (+ x (sum ...xs)) (+ 1 (tally ...xs)))
    (λ x ...xs . (/ (+ x (sum ...xs)) (+ 1 (tally ...xs))))
    --> avg 1 6 2 3 4
    3.2
    --> avg 5
    5
    --> avg
    TypeError thrown in thread 15eb5ee5:
            Expected at least 1 arguments to `(λ x ...xs . (/ (+ x (sum ...xs)) ...))'.
        at entity avg  1:1
        at (λ x ...xs . (/ (+ x (sum ...xs)) ...))  1:11
\end{Verbatim}

Equipped with the power of variadic functions and recursion, the next natural step is to define $\mu$-recursive functions. Consider the following \textit{basic} $\mu$-recursive functions:

\begin{itemize}
    \item For all natural numbers $i, k$ where $0 \le i \le k$, the projection function (sometimes also called the identity function when $i=0$) is defined as $P_i^k(x_0, \dots, x_k)=x_i$. The projection function is a built-in operator in KamilaLisp, where \verb|#a| is equivalent to $P_a^k$.
    \item For each natural $n$ and $k$, the constant function $C_n^k$ is defined as $C_n^k(x_0, \dots, x_k) = x_n$. This is easily implemented using the previously discussed projection function as \verb|$(#0 n)|.
    \item For each natural $n$, the successor function $S_n$ is defined as $S_n(x) = x + 1$. This is easily implemented using just function composition - \verb|$(+ 1)|.
\end{itemize}

The $\mu$-recursive composition operator (also called the substitution operator) defined for an $m$-ary function $h(x_0, \dots, x_m)$ and exactly $m$ $n$-ary functions $g_0(x_0, \dots, x_n), \dots, g_m(x_0, \dots, x_n)$ as $h\circ(g_0, \dots, g_m) = f$ where $f(x_0, \dots, x_n) = h(g_0(x_0, \dots, x_n), \dots, g_m(x_0, \dots, x_n))$. This definition is essentially equivalent to KamilaLisp \textit{forks} - \verb|[h g_0 ... g_m] x_0 ... x_k|.

The $\mu$-recursive primitive recursion operator $\rho(g,h)=f$ for $k$-ary function $g(x_0,\dots,x_k)$, $k+2$-ary function $h(y,z,x_0,\dots,x_k)$ and $k+1$-ary function $f$ yields the following piecewise function:

\begin{equation*}
f(a,x_0,\dots,x_k)=
    \begin{cases}
        g(x_0,\dots,x_k) & \text{if } x = 0\\
        h(a-1,f(a,x_0,\dots,x_k),x_0,\dots,x_k) & \text{if } x \ne 0
    \end{cases}
\end{equation*}

The KamilaLisp implementation of this concept is slightly more involved, requiring the \verb|lift| function to apply a function on a existing variadic parameter pack:

\begin{Verbatim}
    --> defun mu-prim-rec (g h) (
    ...    lambda (a ...xs) (
    ...        if (= a 0)
    ...            (lift g ...xs)
    ...            (lift $(h (- a 1) (lift $(mu-prim-rec g h) ...xs)) ...xs)))
\end{Verbatim}

The $\mu$-recursive \textit{minimization} operator is less demanding to implement. Intuitively, minimisation seeks, beginning the search from 0 and proceeding upwards, the smallest argument that causes the function to return zero; if there is no such argument, of if one encounters an argument for which f is not defined, then the search never terminates, and is not defined for the argument.

\begin{Verbatim}
    --> defun mu-min f (lambda ...xs (let-seq (
    ...    (defun mu-min-iter i (if (lift f ...xs) (&0 (S i)) i))
    ...    (mu-min-iter 0))))
\end{Verbatim}
